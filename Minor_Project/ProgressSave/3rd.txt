#include <GL/freeglut.h>
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib> // for rand()

// Define the button structure
struct Button {
    std::string label;
    float x, y, width, height;
    void (*onClick)();
};

// Declare buttons and floating letters
std::vector<Button> buttons;
std::vector<std::pair<char, std::pair<float, float>>> floatingLetters;

// Window size
int windowWidth = 800;
int windowHeight = 600;

// Colors for gradient background
float topColor[] = {0.2f, 0.6f, 1.0f};    // Light blue
float bottomColor[] = {0.1f, 0.3f, 0.5f}; // Darker blue

// Function Prototypes
void display();
void reshape(int, int);
void onMouseClick(int, int, int, int);
void renderButton(Button &);
void playButtonAction();
void continueButtonAction();
void achievementsButtonAction();
void rewardsButtonAction();
void leaderboardButtonAction();
void howToPlayButtonAction();
void settingsButtonAction();
void exitButtonAction();
void drawText(float, float, const std::string &);
void drawGradientBackground();
void drawFloatingLetters();
void initFloatingLetters();

// Initialize buttons with labels, positions, and actions
void initButtons() {
    buttons.push_back({"Play", 100, 450, 200, 50, playButtonAction});
    buttons.push_back({"Continue Progress", 100, 370, 200, 50, continueButtonAction});
    buttons.push_back({"Achievements", 100, 290, 200, 50, achievementsButtonAction});
    buttons.push_back({"Rewards", 100, 210, 200, 50, rewardsButtonAction});
    buttons.push_back({"Leaderboard", 100, 130, 200, 50, leaderboardButtonAction});
    buttons.push_back({"How to Play", 400, 450, 200, 50, howToPlayButtonAction});
    buttons.push_back({"Settings", 400, 370, 200, 50, settingsButtonAction});
    buttons.push_back({"Exit", 400, 290, 200, 50, exitButtonAction});
}

// Display function for rendering the intro window
void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    // Draw gradient background
    drawGradientBackground();

    // Draw floating letters in the background
    drawFloatingLetters();

    // Draw game logo at the center top
    drawText(250, 550, "AI Crossword Game");

    // Draw tagline below the game logo
    drawText(240, 520, "Unleash the Puzzle Master in You!");

    // Render all buttons
    for (Button &button : buttons) {
        renderButton(button);
    }

    glutSwapBuffers();
}

// Render each button with a label
void renderButton(Button &button) {
    // Draw button rectangle
    glColor3f(0.2f, 0.6f, 0.8f); // Button color
    glBegin(GL_QUADS);
    glVertex2f(button.x, button.y);
    glVertex2f(button.x + button.width, button.y);
    glVertex2f(button.x + button.width, button.y - button.height);
    glVertex2f(button.x, button.y - button.height);
    glEnd();

    // Draw button label
    drawText(button.x + 30, button.y - 30, button.label);
}

// Reshape window callback
void reshape(int width, int height) {
    windowWidth = width;
    windowHeight = height;
    glViewport(0, 0, windowWidth, windowHeight);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, windowWidth, 0, windowHeight);
    glMatrixMode(GL_MODELVIEW);
}

// Handle mouse click events
void onMouseClick(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        for (Button &btn : buttons) {
            if (x > btn.x && x < btn.x + btn.width && windowHeight - y > btn.y - btn.height && windowHeight - y < btn.y) {
                btn.onClick();
            }
        }
    }
}

// Draw text on the screen
void drawText(float x, float y, const std::string &text) {
    glColor3f(1, 1, 1); // Text color
    glRasterPos2f(x, y);
    for (char c : text) {
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
    }
}

// Draw a vertical gradient background
void drawGradientBackground() {
    glBegin(GL_QUADS);
    glColor3fv(topColor);
    glVertex2f(0, windowHeight);
    glVertex2f(windowWidth, windowHeight);
    glColor3fv(bottomColor);
    glVertex2f(windowWidth, 0);
    glVertex2f(0, 0);
    glEnd();
}

// Initialize floating letters with random positions
void initFloatingLetters() {
    const std::string letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (int i = 0; i < 20; i++) {
        float x = rand() % windowWidth;
        float y = rand() % windowHeight;
        char letter = letters[rand() % letters.size()];
        floatingLetters.push_back({letter, {x, y}});
    }
}

// Draw floating letters in the background
void drawFloatingLetters() {
    for (auto &letter : floatingLetters) {
        drawText(letter.second.first, letter.second.second, std::string(1, letter.first));
        // Make letters slowly move upwards
        letter.second.second += 0.1f;
        if (letter.second.second > windowHeight) letter.second.second = 0;
    }
}

// Button Action Functions
void playButtonAction() {
    std::cout << "Play Button Pressed!" << std::endl;
    // Transition to the game window
}

void continueButtonAction() {
    std::cout << "Continue Progress Button Pressed!" << std::endl;
}

void achievementsButtonAction() {
    std::cout << "Achievements Button Pressed!" << std::endl;
}

void rewardsButtonAction() {
    std::cout << "Rewards Button Pressed!" << std::endl;
}

void leaderboardButtonAction() {
    std::cout << "Leaderboard Button Pressed!" << std::endl;
}

void howToPlayButtonAction() {
    std::cout << "How to Play Button Pressed!" << std::endl;
}

void settingsButtonAction() {
    std::cout << "Settings Button Pressed!" << std::endl;
}

void exitButtonAction() {
    std::cout << "Exit Button Pressed!" << std::endl;
    exit(0);
}

// Main function
int main(int argc, char **argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(windowWidth, windowHeight);
    glutCreateWindow("AI Crossword Game");

    // Initialize buttons and floating letters
    initButtons();
    initFloatingLetters();

    // Set up callbacks
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMouseFunc(onMouseClick);
    glutIdleFunc(display); // Constantly redraw for floating letters

    // Set clear color to dark background
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

    glutMainLoop();
    return 0;
}












#include <freeglut.h> 
#include <iostream>
#include <memory>
#define STB_IMAGE_IMPLEMENTATION
#include "Header1.h"  // Include stb_image for texture loading

// Game state enum to track intro screen or game screen
enum class GameState { INTRO, GAME };

class CrosswordGame {
public:
    CrosswordGame(int width, int height);
    void initOpenGL();
    void display();
    void handleMouse(int button, int state, int x, int y);
    void update();

private:
    GLuint loadTexture(const char* filename);
    void drawBackground();
    void drawButtonBackground(); // New function
    void drawPlayButton();
    void drawHTPButton();
    void drawGameGrid();
    void drawExitButton(); // New function for exit button

    int windowWidth, windowHeight;
    // New size for the button background
    const int buttonBackgroundWidth = 600;  // Increase width
    const int buttonBackgroundHeight = 800;  // Increase height
    const int Horizontaloffset = 80;
    const int verticalOffset = -70;
    const int HTPverticaloffset = 20;
    const int exitButtonSize = 50; // Size of the exit button

    int buttonX, buttonY, buttonWidth, buttonHeight;
    GLuint backgroundTexture;
    GLuint buttonTexture; // Texture for the button
    GLuint HTPButtonTexture;
    GLuint buttonBackgroundTexture; // Texture for the background behind the button
    GLuint exitButtonTexture; // Texture for the exit button
    GameState currentState;
    const int gridSize = 10;  // Size of the crossword grid
};

// Constructor
CrosswordGame::CrosswordGame(int width, int height)
    : windowWidth(width), windowHeight(height),
    buttonWidth(300), buttonHeight(150),
    currentState(GameState::INTRO) {
    // Center the button
    buttonX = (windowWidth - buttonWidth) / 2;
    buttonY = (windowHeight - buttonHeight) / 2 - 280;
}

// Initialize OpenGL settings
void CrosswordGame::initOpenGL() {
    glClearColor(1.0, 1.0, 1.0, 1.0);  // White background

    // Load textures
    backgroundTexture = loadTexture("D:/Minor_Project/Props/Bck.png");
    buttonTexture = loadTexture("D:/Minor_Project/Props/h.png");
    buttonBackgroundTexture = loadTexture("D:/Minor_Project/Props/c.png");
    HTPButtonTexture = loadTexture("D:/Minor_Project/Props/h.png");
    exitButtonTexture = loadTexture("D:/Minor_Project/Props/L.png"); // Load exit button texture

    if (!backgroundTexture || !buttonTexture || !buttonBackgroundTexture || !HTPButtonTexture || !exitButtonTexture) {
        std::cerr << "Failed to load textures." << std::endl;
        exit(1);
    }

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

GLuint CrosswordGame::loadTexture(const char* filename) {
    int width, height, channels;
    unsigned char* data = stbi_load(filename, &width, &height, &channels, 0);

    if (!data) {
        std::cerr << "Failed to load texture: " << filename << std::endl;
        return 0;
    }

    GLuint texture;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);

    GLenum format = (channels == 4) ? GL_RGBA : GL_RGB;
    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

    stbi_image_free(data);
    return texture;
}

void CrosswordGame::drawBackground() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, backgroundTexture);

    // Draw the full-screen background
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(-1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f); glVertex2f(1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f); glVertex2f(1.0f, 1.0f);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(-1.0f, 1.0f);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// New function to draw the background behind the play button
void CrosswordGame::drawButtonBackground() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonBackgroundTexture);

    // Adjust the buttonY by adding the verticalOffset to move it down
    float adjustedButtonX = buttonX - Horizontaloffset;
    float adjustedButtonY = buttonY + verticalOffset;

    // Draw the larger button background as a textured quad
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2f((adjustedButtonX - (buttonBackgroundWidth - buttonWidth) / 2) / (windowWidth / 2.0) - 1.0,
        adjustedButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2f((adjustedButtonX + buttonBackgroundWidth) / (windowWidth / 2.0) - 1.0,
        adjustedButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2f((adjustedButtonX + buttonBackgroundWidth) / (windowWidth / 2.0) - 1.0,
        (adjustedButtonY + buttonBackgroundHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2f((adjustedButtonX - (buttonBackgroundWidth - buttonWidth) / 2) / (windowWidth / 2.0) - 1.0,
        (adjustedButtonY + buttonBackgroundHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// Draw the Play button using the texture
void CrosswordGame::drawPlayButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonTexture);

    // Calculate the adjusted Y position for the Play button
    int adjustedPlayButtonY = buttonY + buttonHeight + HTPverticaloffset; // Adjusted to HTP button position

    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, adjustedPlayButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, adjustedPlayButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, (adjustedPlayButtonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, (adjustedPlayButtonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

void CrosswordGame::drawHTPButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonTexture);

    // Use the original Y position of the Play button for HTP
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, buttonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, buttonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, (buttonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, (buttonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}
// New function to draw the exit button
void CrosswordGame::drawExitButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, exitButtonTexture);

    // Position for the exit button in the top right corner
    int exitButtonX = windowWidth - exitButtonSize - 20; // 20 pixels from the right
    int exitButtonY = windowHeight - exitButtonSize - 20; // 20 pixels from the top

    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(exitButtonX / (windowWidth / 2.0) - 1.0, exitButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((exitButtonX + exitButtonSize) / (windowWidth / 2.0) - 1.0, exitButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((exitButtonX + exitButtonSize) / (windowWidth / 2.0) - 1.0, (exitButtonY + exitButtonSize) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(exitButtonX / (windowWidth / 2.0) - 1.0, (exitButtonY + exitButtonSize) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

void CrosswordGame::drawGameGrid() {
    glColor3f(0.8, 0.8, 0.8);  // Light gray background for the grid

    float cellSize = 2.0f / gridSize;
    for (int i = 0; i < gridSize; ++i) {
        for (int j = 0; j < gridSize; ++j) {
            if ((i + j) % 2 == 0) {
                glColor3f(1.0, 1.0, 1.0);  // White cell
            }
            else {
                glColor3f(0.0, 0.0, 0.0);  // Black cell
            }
            float x = i * cellSize - 1.0f;
            float y = j * cellSize - 1.0f;
            glBegin(GL_QUADS);
            glVertex2f(x, y);
            glVertex2f(x + cellSize, y);
            glVertex2f(x + cellSize, y + cellSize);
            glVertex2f(x, y + cellSize);
            glEnd();
        }
    }
}

// Display function to render scenes
void CrosswordGame::display() {
    glClear(GL_COLOR_BUFFER_BIT);

    if (currentState == GameState::INTRO) {
        drawBackground();
        drawButtonBackground(); // Draw the button background first
        drawHTPButton();
        drawPlayButton();
        drawExitButton(); // Draw the exit button
    }
    else if (currentState == GameState::GAME) {
        drawGameGrid();
        drawExitButton(); // Draw the exit button in the game screen as well
    }

    glutSwapBuffers();
}

// Handle mouse clicks for the play button and exit button
void CrosswordGame::handleMouse(int button, int state, int x, int y) {
    if (currentState == GameState::INTRO && button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        int mouseX = x;
        int mouseY = windowHeight - y;  // Convert to OpenGL coordinates

        // Check if the play button is clicked
        if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY + buttonHeight + HTPverticaloffset && mouseY <= buttonY + buttonHeight * 2 + HTPverticaloffset) {
            currentState = GameState::GAME;  // Transition to the crossword game
            glutPostRedisplay();  // Ensure the screen refreshes after state change
        }

        // Check if the exit button is clicked
        int exitButtonX = windowWidth - exitButtonSize - 20; // 20 pixels from the right
        int exitButtonY = windowHeight - exitButtonSize - 20; // 20 pixels from the top

        if (mouseX >= exitButtonX && mouseX <= exitButtonX + exitButtonSize &&
            mouseY >= exitButtonY && mouseY <= exitButtonY + exitButtonSize) {
            exit(0); // Exit the application
        }
    }
}


// Update function
void CrosswordGame::update() {
    glutPostRedisplay();
}

// Global game instance
std::unique_ptr<CrosswordGame> gameInstance;

// Wrapper functions for OpenGL callbacks
void displayWrapper() { gameInstance->display(); }
void mouseWrapper(int button, int state, int x, int y) { gameInstance->handleMouse(button, state, x, y); }
void idleWrapper() { gameInstance->update(); }

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);

    glutCreateWindow("AI Crossword Game");
    glutInitWindowSize(800, 600);
    glutFullScreen();

    int screenWidth = glutGet(GLUT_SCREEN_WIDTH);
    int screenHeight = glutGet(GLUT_SCREEN_HEIGHT);

    gameInstance = std::make_unique<CrosswordGame>(screenWidth, screenHeight);
    gameInstance->initOpenGL();

    glutDisplayFunc(displayWrapper);
    glutMouseFunc(mouseWrapper);
    glutIdleFunc(idleWrapper);

    glutMainLoop();
    return 0;
}











