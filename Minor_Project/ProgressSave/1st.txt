#include <freeglut.h> 
#include <iostream>
#include <memory>
#define STB_IMAGE_IMPLEMENTATION
#include "Header1.h"  // Include stb_image for texture loading

// Game state enum to track intro screen or game screen
enum class GameState { INTRO, GAME };

class CrosswordGame {
public:
    CrosswordGame(int width, int height);
    void initOpenGL();
    void display();
    void handleMouse(int button, int state, int x, int y);
    void update();

private:
    GLuint loadTexture(const char* filename);
    void drawBackground();
    void drawButtonBackground(); // New function
    void drawPlayButton();
    void drawHTPButton();
    void drawGameGrid();
    void drawExitButton(); // New function for exit button

    int windowWidth, windowHeight;
    // New size for the button background
    const int buttonBackgroundWidth = 600;  // Increase width
    const int buttonBackgroundHeight = 800;  // Increase height
    const int Horizontaloffset = 80;
    const int verticalOffset = -70;
    const int HTPverticaloffset = 20;
    const int exitButtonSize = 50; // Size of the exit button

    int buttonX, buttonY, buttonWidth, buttonHeight;
    GLuint backgroundTexture;
    GLuint buttonTexture; // Texture for the button
    GLuint HTPButtonTexture;
    GLuint buttonBackgroundTexture; // Texture for the background behind the button
    GLuint exitButtonTexture; // Texture for the exit button
    GameState currentState;
    const int gridSize = 10;  // Size of the crossword grid
};

// Constructor
CrosswordGame::CrosswordGame(int width, int height)
    : windowWidth(width), windowHeight(height),
    buttonWidth(300), buttonHeight(150),
    currentState(GameState::INTRO) {
    // Center the button
    buttonX = (windowWidth - buttonWidth) / 2;
    buttonY = (windowHeight - buttonHeight) / 2 - 280;
}

// Initialize OpenGL settings
void CrosswordGame::initOpenGL() {
    glClearColor(1.0, 1.0, 1.0, 1.0);  // White background

    // Load textures
    backgroundTexture = loadTexture("D:/Minor_Project/Props/Bck.png");
    buttonTexture = loadTexture("D:/Minor_Project/Props/h.png");
    buttonBackgroundTexture = loadTexture("D:/Minor_Project/Props/c.png");
    HTPButtonTexture = loadTexture("D:/Minor_Project/Props/h.png");
    exitButtonTexture = loadTexture("D:/Minor_Project/Props/L.png"); // Load exit button texture

    if (!backgroundTexture || !buttonTexture || !buttonBackgroundTexture || !HTPButtonTexture || !exitButtonTexture) {
        std::cerr << "Failed to load textures." << std::endl;
        exit(1);
    }

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

GLuint CrosswordGame::loadTexture(const char* filename) {
    int width, height, channels;
    unsigned char* data = stbi_load(filename, &width, &height, &channels, 0);

    if (!data) {
        std::cerr << "Failed to load texture: " << filename << std::endl;
        return 0;
    }

    GLuint texture;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);

    GLenum format = (channels == 4) ? GL_RGBA : GL_RGB;
    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

    stbi_image_free(data);
    return texture;
}

void CrosswordGame::drawBackground() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, backgroundTexture);

    // Draw the full-screen background
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(-1.0f, -1.0f);
    glTexCoord2f(1.0f, 1.0f); glVertex2f(1.0f, -1.0f);
    glTexCoord2f(1.0f, 0.0f); glVertex2f(1.0f, 1.0f);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(-1.0f, 1.0f);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// New function to draw the background behind the play button
void CrosswordGame::drawButtonBackground() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonBackgroundTexture);

    // Adjust the buttonY by adding the verticalOffset to move it down
    float adjustedButtonX = buttonX - Horizontaloffset;
    float adjustedButtonY = buttonY + verticalOffset;

    // Draw the larger button background as a textured quad
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2f((adjustedButtonX - (buttonBackgroundWidth - buttonWidth) / 2) / (windowWidth / 2.0) - 1.0,
        adjustedButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2f((adjustedButtonX + buttonBackgroundWidth) / (windowWidth / 2.0) - 1.0,
        adjustedButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2f((adjustedButtonX + buttonBackgroundWidth) / (windowWidth / 2.0) - 1.0,
        (adjustedButtonY + buttonBackgroundHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2f((adjustedButtonX - (buttonBackgroundWidth - buttonWidth) / 2) / (windowWidth / 2.0) - 1.0,
        (adjustedButtonY + buttonBackgroundHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// Draw the Play button using the texture
void CrosswordGame::drawPlayButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonTexture);

    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, buttonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, buttonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, (buttonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, (buttonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

void CrosswordGame::drawHTPButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, buttonTexture);

    // Calculate the adjusted Y position for the HTP button
    int adjustedHTPButtonY = buttonY + buttonHeight + HTPverticaloffset; // Adjusting the Y position

    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, adjustedHTPButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, adjustedHTPButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((buttonX + buttonWidth) / (windowWidth / 2.0) - 1.0, (adjustedHTPButtonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(buttonX / (windowWidth / 2.0) - 1.0, (adjustedHTPButtonY + buttonHeight) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// New function to draw the exit button
void CrosswordGame::drawExitButton() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, exitButtonTexture);

    // Position for the exit button in the top right corner
    int exitButtonX = windowWidth - exitButtonSize - 20; // 20 pixels from the right
    int exitButtonY = windowHeight - exitButtonSize - 20; // 20 pixels from the top

    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f); glVertex2f(exitButtonX / (windowWidth / 2.0) - 1.0, exitButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 1.0f); glVertex2f((exitButtonX + exitButtonSize) / (windowWidth / 2.0) - 1.0, exitButtonY / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(1.0f, 0.0f); glVertex2f((exitButtonX + exitButtonSize) / (windowWidth / 2.0) - 1.0, (exitButtonY + exitButtonSize) / (windowHeight / 2.0) - 1.0);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(exitButtonX / (windowWidth / 2.0) - 1.0, (exitButtonY + exitButtonSize) / (windowHeight / 2.0) - 1.0);
    glEnd();

    glDisable(GL_TEXTURE_2D);
}

void CrosswordGame::drawGameGrid() {
    glColor3f(0.8, 0.8, 0.8);  // Light gray background for the grid

    float cellSize = 2.0f / gridSize;
    for (int i = 0; i < gridSize; ++i) {
        for (int j = 0; j < gridSize; ++j) {
            if ((i + j) % 2 == 0) {
                glColor3f(1.0, 1.0, 1.0);  // White cell
            }
            else {
                glColor3f(0.0, 0.0, 0.0);  // Black cell
            }
            float x = i * cellSize - 1.0f;
            float y = j * cellSize - 1.0f;
            glBegin(GL_QUADS);
            glVertex2f(x, y);
            glVertex2f(x + cellSize, y);
            glVertex2f(x + cellSize, y + cellSize);
            glVertex2f(x, y + cellSize);
            glEnd();
        }
    }
}

// Display function to render scenes
void CrosswordGame::display() {
    glClear(GL_COLOR_BUFFER_BIT);

    if (currentState == GameState::INTRO) {
        drawBackground();
        drawButtonBackground(); // Draw the button background first
        drawHTPButton();
        drawPlayButton();
        drawExitButton(); // Draw the exit button
    }
    else if (currentState == GameState::GAME) {
        drawGameGrid();
        drawExitButton(); // Draw the exit button in the game screen as well
    }

    glutSwapBuffers();
}

// Handle mouse clicks for the play button and exit button
void CrosswordGame::handleMouse(int button, int state, int x, int y) {
    if (currentState == GameState::INTRO && button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        int mouseX = x;
        int mouseY = windowHeight - y;

        // Check if the play button is clicked
        if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
            mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {
            currentState = GameState::GAME;  // Transition to the crossword game
        }

        // Check if the exit button is clicked
        int exitButtonX = windowWidth - exitButtonSize - 20; // 20 pixels from the right
        int exitButtonY = windowHeight - exitButtonSize - 20; // 20 pixels from the top

        if (mouseX >= exitButtonX && mouseX <= exitButtonX + exitButtonSize &&
            mouseY >= exitButtonY && mouseY <= exitButtonY + exitButtonSize) {
            exit(0); // Exit the application
        }
    }
}

// Update function
void CrosswordGame::update() {
    glutPostRedisplay();
}

// Global game instance
std::unique_ptr<CrosswordGame> gameInstance;

// Wrapper functions for OpenGL callbacks
void displayWrapper() { gameInstance->display(); }
void mouseWrapper(int button, int state, int x, int y) { gameInstance->handleMouse(button, state, x, y); }
void idleWrapper() { gameInstance->update(); }

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);

    glutCreateWindow("AI Crossword Game");
    glutInitWindowSize(800, 600);
    glutFullScreen();

    int screenWidth = glutGet(GLUT_SCREEN_WIDTH);
    int screenHeight = glutGet(GLUT_SCREEN_HEIGHT);

    gameInstance = std::make_unique<CrosswordGame>(screenWidth, screenHeight);
    gameInstance->initOpenGL();

    glutDisplayFunc(displayWrapper);
    glutMouseFunc(mouseWrapper);
    glutIdleFunc(idleWrapper);

    glutMainLoop();
    return 0;
}
